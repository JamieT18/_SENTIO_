"""
Base strategy class for Sentio
Provides the foundation for all trading strategies
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum
from datetime import datetime
import pandas as pd
import numpy as np
from sentio.analysis.regime_detection import RegimeDetector


class SignalType(str, Enum):
    """Trading signal types"""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


class StrategyType(str, Enum):
    """Strategy classification"""

    SCALPING = "scalping"
    DAY_TRADING = "day_trading"
    SWING = "swing"
    TREND_FOLLOWING = "trend_following"
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    BREAKOUT = "breakout"
    TJR = "tjr"
    CUSTOM = "custom"


@dataclass
class TradingSignal:
    """
    Trading signal with confidence and metadata
    """

    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    strategy_name: str
    symbol: str
    timestamp: datetime
    price: float
    volume: Optional[int] = None
    position_size: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    reasoning: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

    def __post_init__(self):
        """Validate signal data"""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(
                f"Confidence must be between 0 and 1, got {self.confidence}"
            )
        if self.confidence < 0.5:
            # Low confidence signals default to HOLD
            self.signal_type = SignalType.HOLD


class BaseStrategy(ABC):
    def adapt_to_regime(self, data: pd.DataFrame, regime: str) -> None:
        """
        Adapt strategy parameters based on detected market regime (bull, bear, neutral).
        """
        if regime == "bull":
            self.min_confidence = min(self.min_confidence + 0.05, 1.0)
        elif regime == "bear":
            self.min_confidence = max(self.min_confidence - 0.05, 0.5)
        # Log adaptation
        print(f"{self.name} adapted to regime {regime}, min_confidence={self.min_confidence}")


    def explain_signal(self, signal: TradingSignal, analysis: Dict[str, Any], feature_importance: Optional[Dict[str, float]] = None, diagnostics: Optional[Dict[str, Any]] = None) -> str:
        """
        Advanced explanation: includes feature importance and diagnostics.
        """
        explanation = f"Signal {signal.signal_type.value} generated by {self.name} with confidence {signal.confidence:.2f}. Reason: {signal.reasoning or 'N/A'}"
        if feature_importance:
            top_features = sorted(feature_importance.items(), key=lambda x: -x[1])[:3]
            explanation += f" | Top features: {', '.join(f'{k} ({v:.2f})' for k, v in top_features)}"
        if diagnostics:
            explanation += f" | Diagnostics: {diagnostics}"
        return explanation


    def quantify_uncertainty(self, data: pd.DataFrame, analysis: Dict[str, Any]) -> float:
        """
        Improved uncertainty quantification: std of returns, ensemble disagreement, Bayesian estimate.
        """
        returns = data["close"].pct_change().dropna()
        std_uncertainty = float(np.std(returns))
        # Example: ensemble disagreement (if available)
        disagreement = analysis.get("ensemble_disagreement", 0.0)
        # Bayesian uncertainty stub (could be replaced with real model)
        bayesian_uncertainty = analysis.get("bayesian_uncertainty", 0.0)
        return std_uncertainty + disagreement + bayesian_uncertainty


    def meta_learning_hook(self, meta_info: Dict[str, Any]) -> None:
        """
        Enhanced meta-learning: auto-tune parameters, learn from external signals, optimize for ROI.
        """
        if "boost" in meta_info:
            self.min_confidence = min(self.min_confidence + meta_info["boost"], 1.0)
        if "decay" in meta_info:
            self.min_confidence = max(self.min_confidence - meta_info["decay"], 0.5)
        if "external_data" in meta_info:
            # Example: adjust based on macro, sentiment, options flow
            ext = meta_info["external_data"]
            if ext.get("macro_trend") == "bull":
                self.min_confidence = min(self.min_confidence + 0.02, 1.0)
            elif ext.get("macro_trend") == "bear":
                self.min_confidence = max(self.min_confidence - 0.02, 0.5)
        if "roi_boost" in meta_info:
            # Directly optimize for ROI
            self.min_confidence = min(self.min_confidence + meta_info["roi_boost"], 1.0)
        print(f"{self.name} meta-learning update: {meta_info}")
    """
    Abstract base class for all trading strategies

    Each strategy must implement:
    - analyze(): Main analysis logic
    - get_signal(): Generate trading signal
    - calculate_confidence(): Compute signal confidence
    """

    def __init__(
        self,
        name: str,
        strategy_type: StrategyType,
        timeframe: str = "5min",
        min_confidence: float = 0.65,
        enabled: bool = True,
    ):
        """
        Initialize strategy

        Args:
            name: Strategy name
            strategy_type: Type of strategy
            timeframe: Trading timeframe (e.g., '1min', '5min', '1h', '1d')
            min_confidence: Minimum confidence threshold for signals
            enabled: Whether strategy is active
        """
        self.name = name
        self.strategy_type = strategy_type
        self.timeframe = timeframe
        self.min_confidence = min_confidence
        self.enabled = enabled
        self.last_signal: Optional[TradingSignal] = None
        self.performance_history: List[Dict[str, Any]] = []

    @abstractmethod
    def analyze(self, data: pd.DataFrame, regime: str = None, external_context: dict = None, diagnostics: dict = None) -> Dict[str, Any]:
        """
        Analyze market data and compute indicators

        Args:
            data: OHLCV DataFrame with market data

        Returns:
            Dictionary with analysis results and indicators
        """
        # Example implementation: compute basic indicators
        indicators = {
            "sma": data['close'].rolling(window=14).mean().iloc[-1],
            "ema": data['close'].ewm(span=14, adjust=False).mean().iloc[-1],
            "rsi": (100 - (100 / (1 + (data['close'].pct_change().rolling(window=14).mean())))),
            "regime": regime,
            "external_context": external_context,
            "diagnostics": diagnostics,
        }
        return indicators

    @abstractmethod
    def get_signal(self, data: pd.DataFrame, analysis: Dict[str, Any], regime: str = None, external_context: dict = None, diagnostics: dict = None) -> TradingSignal:
        """
        Generate trading signal based on analysis

        Args:
            data: OHLCV DataFrame
            analysis: Results from analyze()

        Returns:
            Trading signal with confidence
        """
        # Example implementation: simple momentum signal
        if analysis["sma"] > analysis["ema"]:
            return TradingSignal(
                "buy",
                confidence=0.7,
                metadata={
                    "regime": regime or analysis.get("regime"),
                    "external_context": external_context or analysis.get("external_context"),
                    "diagnostics": diagnostics or analysis.get("diagnostics"),
                }
            )
        else:
            return TradingSignal(
                "sell",
                confidence=0.6,
                metadata={
                    "regime": regime or analysis.get("regime"),
                    "external_context": external_context or analysis.get("external_context"),
                    "diagnostics": diagnostics or analysis.get("diagnostics"),
                }
            )


    @abstractmethod
    def calculate_confidence(
        self, data: pd.DataFrame, analysis: Dict[str, Any], risk_metrics: Optional[Dict[str, Any]] = None, regime: str = None, external_context: dict = None, diagnostics: dict = None
    ) -> float:
        """
        Risk-adjusted confidence scoring, supports multi-objective optimization.
        """
        rsi = analysis.get("rsi", 50)
        base_conf = 0.6
        if rsi > 70:
            base_conf = 0.4
        elif rsi < 30:
            base_conf = 0.8
        # Risk adjustment
        if risk_metrics:
            drawdown = risk_metrics.get("max_drawdown", 0.0)
            sharpe = risk_metrics.get("sharpe_ratio", 0.0)
            base_conf += min(sharpe * 0.05, 0.1)
            base_conf -= min(abs(drawdown) * 0.05, 0.1)
        # Regime/context/diagnostics adjustment
        if regime == "bull":
            base_conf += 0.05
        elif regime == "bear":
            base_conf -= 0.05
        if diagnostics and diagnostics.get("error_rate", 0) > 0.1:
            base_conf -= 0.05
        if external_context and external_context.get("macro") == "positive":
            base_conf += 0.02
        return min(max(base_conf, 0.0), 1.0)

    def execute(self, data: pd.DataFrame, regime: str = None, external_context: dict = None, diagnostics: dict = None) -> TradingSignal:
        """
        Main execution method - runs analysis and generates signal

        Args:
            data: OHLCV DataFrame

        Returns:
            Trading signal
        """
        if not self.enabled:
            return self._create_hold_signal(data)

        # Validate data
        if data is None or data.empty:
            raise ValueError(f"Strategy {self.name}: No data provided")

        # Automated regime detection integration
        detector = RegimeDetector()
        detected_context = detector.regime_context(data) if data is not None else {}
        regime_val = regime or detected_context.get('regime')

        # Run analysis
        analysis = self.analyze(data, regime=regime_val, external_context=external_context, diagnostics=diagnostics)

        # Calculate confidence
        confidence = self.calculate_confidence(data, analysis, regime=regime_val, external_context=external_context, diagnostics=diagnostics)

        # Generate signal
        signal = self.get_signal(data, analysis, regime=regime_val, external_context=external_context, diagnostics=diagnostics)

        # Update last signal
        self.last_signal = signal

        # Attach regime detection context to signal metadata
        if signal.metadata is None:
            signal.metadata = {}
        signal.metadata['regime_detection'] = detected_context

        return signal

    def _create_hold_signal(self, data: pd.DataFrame) -> TradingSignal:
        """Create a HOLD signal"""
        return TradingSignal(
            signal_type=SignalType.HOLD,
            confidence=0.0,
            strategy_name=self.name,
            symbol=getattr(data, "symbol", "UNKNOWN"),
            timestamp=datetime.now(),
            price=data["close"].iloc[-1] if not data.empty else 0.0,
            reasoning="Strategy disabled or no clear signal",
        )

    def update_performance(self, trade_result: Dict[str, Any]):
        """
        Update strategy performance metrics

        Args:
            trade_result: Dictionary with trade outcome
        """
        self.performance_history.append(
            {"timestamp": datetime.now(), "trade_result": trade_result}
        )

    def get_performance_metrics(self) -> Dict[str, Any]:
        """
        Calculate strategy performance metrics

        Returns:
            Dictionary with performance statistics
        """
        if not self.performance_history:
            return {
                "total_trades": 0,
                "win_rate": 0.0,
                "avg_return": 0.0,
                "sharpe_ratio": 0.0,
            }

        trades = [t["trade_result"] for t in self.performance_history]
        wins = [t for t in trades if t.get("profit", 0) > 0]

        return {
            "total_trades": len(trades),
            "win_rate": len(wins) / len(trades) if trades else 0.0,
            "avg_return": np.mean([t.get("profit", 0) for t in trades]),
            "total_return": sum([t.get("profit", 0) for t in trades]),
            "max_drawdown": self._calculate_max_drawdown(trades),
        }

    def _calculate_max_drawdown(self, trades: List[Dict[str, Any]]) -> float:
        """Calculate maximum drawdown from trade history"""
        if not trades:
            return 0.0

        cumulative = np.cumsum([t.get("profit", 0) for t in trades])
        running_max = np.maximum.accumulate(cumulative)
        drawdown = (cumulative - running_max) / (running_max + 1e-10)
        return float(np.min(drawdown))

    def reset(self):
        """Reset strategy state"""
        self.last_signal = None
        self.performance_history = []

    def __repr__(self) -> str:
        return f"<Strategy: {self.name} ({self.strategy_type.value})>"
